package com.rigelramadhan.bossqueue.viewmodel

import android.util.Log
import androidx.lifecycle.*
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.firestore.ktx.firestore
import com.google.firebase.ktx.Firebase
import com.rigelramadhan.bossqueue.model.Basket
import com.rigelramadhan.bossqueue.model.Basket.Companion.toBasket
import com.rigelramadhan.bossqueue.model.Food
import com.rigelramadhan.bossqueue.model.Place
import com.rigelramadhan.bossqueue.model.Place.Companion.toPlace
import com.rigelramadhan.bossqueue.repository.BasketRepository
import com.rigelramadhan.bossqueue.repository.FoodRepository
import com.rigelramadhan.bossqueue.repository.PlaceRepository
import com.rigelramadhan.bossqueue.util.LoadingState
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch

class MenuViewModel(private val placeId: String) : ViewModel() {
    private val db = Firebase.firestore

    private val _loading = MutableLiveData<LoadingState>()
    val loading: LiveData<LoadingState> get() = _loading

    private val _foods = MutableLiveData<List<Food>>()
    val foods: LiveData<List<Food>> = _foods

    private val _drinks = MutableLiveData<List<Food>>()
    val drinks: LiveData<List<Food>> = _drinks

    private val _place = MutableLiveData<Place>()
    val place: LiveData<Place> = _place

    private val _basket = MutableLiveData<List<Basket>>()
    val basket: LiveData<List<Basket>> = _basket

    companion object {
        private val TAG = MenuViewModel::class.java.simpleName
    }

    init {
        fetchData()
    }

    private fun fetchData() {
        Log.d(TAG, "PlaceID: $placeId")
        val foods = FoodRepository.getFoodsByPlaceId(placeId)
        _loading.postValue(LoadingState.LOADING)

        viewModelScope.launch(Dispatchers.IO) {
            _foods.postValue(FoodRepository.getFilteredFoods(foods, Food.FOOD))
            _drinks.postValue(FoodRepository.getFilteredFoods(foods, Food.DRINK))
        }

        viewModelScope.launch(Dispatchers.IO) {
            _place.postValue(PlaceRepository.getPlaceById(placeId))
        }

        viewModelScope.launch(Dispatchers.IO) {
            db.collection("baskets")
                .get()
                .addOnSuccessListener { result ->
                    val baskets = mutableListOf<Basket>()
                    for (document in result) {
                        if (document.get("placeId") == placeId &&
                            document.get("userId") == FirebaseAuth.getInstance().uid) {

                            val basket = document.toBasket()
                            baskets.add(basket!!)
                        }
                    }
                    _basket.postValue(baskets)
                }
        }
    }

    fun createBasket(userId: String, foodId: String, placeId: String) {
        viewModelScope.launch(Dispatchers.IO) {
            val basket = hashMapOf(
                "userId" to userId,
                "foodId" to foodId,
                "placeId" to placeId
            )

            db.collection("baskets")
                .add(basket)
                .addOnSuccessListener {
                    Log.d(TAG, "Data set completed, data: $basket")
                    val basketData = Basket(it.id, basket["userId"], basket["placeId"], basket["foodId"])
                    val baskets = BasketRepository.getBasket().value as MutableList<Basket>
                    baskets.add(basketData)
                    BasketRepository.getBasket().postValue(baskets)
                }
        }
    }

    fun deleteBasket(userId: String, foodId: String, placeId: String) {
        viewModelScope.launch(Dispatchers.IO) {
            // TODO: COMPLETE THE DELETE BASKET TO WITH THE SAME AUTOGENERATED BASKET ID
            val basketId = "${userId.subSequence(0, 3)}${foodId.subSequence(0, 3)}${placeId.subSequence(0, 3)}"
            db.collection("baskets").document(basketId).delete()
        }
    }

    class MenuViewModelFactory(private val placeId: String = "0") : ViewModelProvider.NewInstanceFactory() {
        @Suppress("UNCHECKED_CAST")
        override fun <T : ViewModel> create(modelClass: Class<T>): T {
            return MenuViewModel(placeId) as T
        }
    }
}